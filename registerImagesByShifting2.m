%Ryan M Davis 06062016
% INPUT:
%   im1 & im2 images must be rgb (MxNx3)
%   reg_parameters - structure containing scale, rotation, and shift.
%   generatged from the function determineAffineTransform(...)
% NOTES:
%   im1 is unaltered (except for zero padding), while all tranforms are
%   applied to image 2


function [im1_out, im2_out]=registerImagesByShifting2(im1,im2,reg_parameters,varargin)

% assign optional arguments
invar = struct('show_images',0,'inverse',0);
argin = varargin;
invar = generateArgin(invar,argin);

if isa(im1,'uint8') && size(im1,3)==3
    im1=double(im1)/255;
end

if invar.inverse
    reg_parameters.shift_rc=-reg_parameters.shift_rc;
    reg_parameters.scale=1/reg_parameters.scale;
    reg_parameters.rotation=-reg_parameters.rotation;
end

if invar.show_images
    show2images(im1,im2,'before scaling');
end
% resize the smaller image
if size(im1,1)<size(im2,1) %%changed less than to greater than on 8/4/17
    im1=imresize(im1,reg_parameters.scale,'nearest');
else
    im2=imresize(im2,reg_parameters.scale,'nearest');
end

if invar.show_images
    show2images(im1,im2,'before padding');
end

im2_shift=reg_parameters.shift_rc;

% % find the zero-padding needed so that images can be shifted relative to
% % eachother.  Make sure the padded images have even number of rows and
% % columns for convenience later
% padded_row_size=max([size(im1,1) size(im2,1)])+2*abs(im2_shift(1));
% padded_col_size=max([size(im1,2) size(im2,2)])+2*abs(im2_shift(2));
% padded_row_size=padded_row_size+mod(padded_row_size,2);
% padded_col_size=padded_col_size+mod(padded_col_size,2);

% create new zero-padded images
% im1_padded=zeros(reg_parameters.padded_im_size_rc(1),reg_parameters.padded_im_size_rc(2),size(im1,3));
% im2_padded=zeros(reg_parameters.padded_im_size_rc(1),reg_parameters.padded_im_size_rc(2),size(im2,3));
im1_padded=NaN(reg_parameters.padded_im_size_rc(1),reg_parameters.padded_im_size_rc(2),size(im1,3));
im2_padded=NaN(reg_parameters.padded_im_size_rc(1),reg_parameters.padded_im_size_rc(2),size(im2,3));

% works for im1 - 891x698 and im2 = 900x738x3
try
    im1_padded(ceil((reg_parameters.padded_im_size_rc(1)-size(im1,1))/2)+1:ceil((reg_parameters.padded_im_size_rc(1)+size(im1,1))/2),ceil((reg_parameters.padded_im_size_rc(2)-size(im1,2))/2)+1:ceil((reg_parameters.padded_im_size_rc(2)+size(im1,2))/2),:)=im1;
    im2_padded(ceil((reg_parameters.padded_im_size_rc(1)-size(im2,1))/2)+1:ceil((reg_parameters.padded_im_size_rc(1)+size(im2,1))/2),ceil((reg_parameters.padded_im_size_rc(2)-size(im2,2))/2)+1:ceil((reg_parameters.padded_im_size_rc(2)+size(im2,2))/2),:)=im2;
catch
    keyboard;
end
if invar.show_images
    show2images(im1_padded,im2_padded,'before rotation');
end

% rotate the image.  must do this before shifting, because point of rotation
% changes when you shift
im2_rotated=imrotate(im2_padded,reg_parameters.rotation,'nearest','crop'); %% positive angle is ccw

% if im2 is grayscale, replace the zeros generated by imrotate with NaN
if ndims(im2_rotated)==2
    im2_rotated(im2_rotated==0)=NaN;
end

if invar.show_images
    show2images(im1_padded,im2_rotated,'before circshift');
end

% now shift the image
im2_padded=circshift(im2_rotated,round([reg_parameters.shift_rc 0])); % the zero is because we don't need to shift in the RGB channel dimension
% im1_out=im1_padded;

im1_out=im1_padded(reg_parameters.pad_size_rc(1)+1:(end-reg_parameters.pad_size_rc(1)),reg_parameters.pad_size_rc(2)+1:(end-reg_parameters.pad_size_rc(2)),:);
im2_out=im2_padded(reg_parameters.pad_size_rc(1)+1:(end-reg_parameters.pad_size_rc(1)),reg_parameters.pad_size_rc(2)+1:(end-reg_parameters.pad_size_rc(2)),:);

if invar.show_images
    show2images(im1_out,im2_out,'after circshift');
end

end

function show2images(im1,im2,varargin)   
    figure
    subplot(1,2,1);
    imagesc(im1);
    title('im1')
    axis image
    subplot(1,2,2);
    imagesc(im2);
    title('im2');
    axis image
    impixelinfo
    if nargin==3
        set(gcf,'Name',varargin{1});    
    end
end
% figure,imagesc(imfuse(im1_out,im2_out,'blend'));
% keyboard;
% figure,imagesc(im1_out)
% figure,imagesc(im2_out)